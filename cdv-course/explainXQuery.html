
<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml">
   
   	
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      <link rel="stylesheet" type="text/css" href="explain.css" />
      <title>XQuery and eXist</title>
   </head>
   
   
   
   <body>
      <!--#include virtual="top.html" -->
      		
      		  
      <h1><span class="banner">XQuery and the eXist XML Database</span></h1>
      		  
      		  
      		  
      			
      			
      <h3>What’s an XML database and how does it work? </h3>
      			
      <p>XQuery is one of the XML family of languages that builds on what you have learned of XPath, and we use it to work with <dfn>XML databases</dfn>. XML
         databases basically work by storing XML files and building <q>persistent indexes</q> for
         them—and this indexing capacity makes it speedy and efficient to search for elements,
         attribute values and calculate functions (anything you can locate and process with XPath expressions) across
         collections of files. XML databases can run speedily because they build an <dfn>index</dfn> of each file, so that the computer doesn’t have to review the entire file every time you run XQuery code. Basically the database’s index stores the tree structure of XML in the database memory, and makes it available for quick retrieval through XQuery. 
      </p>
      			
      <h3>How to Access our eXist XML database: </h3>
      			
      <p>We are working with a particular XML database installed at the Pittsburgh Supercomputing Center(PSC) called eXist. Usually when we work on homework exercises and on project development, we will be working on the PSC eXist installation, but we can also write and run XQuery locally inside &lt;oXygen/&gt; by clicking on the little <q>XQuery Debugger</q> button right next to the <q>XSLT debugger</q> button in the top right of the &lt;oXygen/&gt; window to work with a batch of files we have saved locally. Fpr our projects we tend to prefer working with an eXist installation either on a server or offline on a local computer because a) eXist has indexing tools that we use to make it more efficient to run over multiple collections stored on a remote server, and b) we can connect the XQuery scripts and XML files we have stored in eXist to our project websites. Here’s how to access our eXist database at the PSC:</p>
      	<ol>
      	   <li>In a web browser, go to <a href="http://dxcvm05.psc.edu:8080/">http://dxcvm05.psc.edu:8080/</a></li>
      	   <li>Wait for eXist to load, and it will show you a page of several icons/images.</li>
      	   <li>Look for the eXide button in the second row of icons and click on it. An interface will open where you can input XQuery code and work with the collections of files we have stored here.</li>
      	   <li>For our first assignments, a login is not strictly necessary, but as you work on projects or if you wish to save your XQuery code to a directory you create here, you will need to log in with a username and password. If you are an enrolled student in one of my digital humanities courses, I will likely have created a login for you, and for details please see Courseweb.</li>
      	</ol>  
      		  
      		  
      <!--2016-03-01 ebb: OLD MODE OF ACCESS from 2013
         <p>eXist is available right now in two "places", in the same way you access our Digital
         Sandbox for developing your project websites:
      </p>
      		  
      <ol>
         <li>In our campus computer labs, without an sremote login: <a href="http://x1.digital.greensburg.pitt.edu:8080/exist/apps/dashboard/index.html       ">http://x1.digital.greensburg.pitt.edu:8080/exist/apps/dashboard/index.html</a><br /></li>
         
         <li>On your OWN computers with a wireless or wired connections. (Please test this ASAP
            following the instructions below to make sure it works for you.)
         </li>       
         
      </ol>
      	      
      <p>To begin, you need to use the secure login, "Network Connect"-\-our private passageway
         to eXist. If you’re enrolled in this class, you’ve been granted access. Here’s what
         to do: 
      </p>
      
      <ol>
         
         <li>Open <b>Internet Explorer</b> or <b>Firefox</b>, and go to <a href="http://sremote.pitt.edu">http://sremote.pitt.edu</a> . (Network Connect won’t be fully functional in other browsers.) If you can’t get
            in through Explorer, try the Firefox browser.
         </li>
         
         <li>With "Network Connect" selected, log in with your Pitt userid and password (the same
            that you use for e-mail and for your Pitt web space)
         </li>
         
         <li>After you log in, you’ll see a link to <b>"Firewall-GBG-DH-DIGITAL-SANDBOX-NetworkConnect."</b> Click on this to bring up a new screen with the words "Network Connect" again-\-this
            time with a "Start" button. <b>Click on the Start Button, and wait</b> until Network Connect seems to have run.
         </li>
         
         <li>Once you’ve done this, you may open ANY web browser (or a new tab in this browser)
            and go to this link to our eXist XML database:<br /><b><a href="http://x1.digital.greensburg.pitt.edu:8080/exist/apps/dashboard/index.html ">http://x1.digital.greensburg.pitt.edu:8080/exist/apps/dashboard/index.html</a></b>
            
         </li>
         
         <li>Here, you may log in locally with:
            
            <ul>
               
               <li>id: your Pitt userid </li>
               
               <li>password: dhclass </li>
               
            </ul>
            <br />
            (After you log in for the first time, change the password to whatever you want.) 
            
         </li>
         
         <li>Open <b>eXide</b> to work on XQuery. 
         </li>
         
         
      </ol>
      -->
      
     
      
      <h3>How the database is organized: </h3>
      			
      <p>eXist holds file directories, or <dfn>>collections</dfn> in a hierarchical structure, so that you can access and query a collection of XML files all together. You might think of a collection as one giant XML file with subfiles inside, so you can step up and down the file directory structure just as you step up and down the directory structure using the same XPath axes you use to search within a single XML document. In the eXist database there is a single root directory called <strong><code>db</code></strong>, with subfolders containing folders (or collections), which may in turn contain their
         own subfolders (more collections), and finally files.  I’ve installed a copy of our
         Georg Forster XML file here, in a collection called <q>voyages</q>, inside a directory
         called <q>pacific</q>, and that means that its address in our database is <code>/db/pacific/voyages/ForsterGeorgComplete.xml</code>, starting from the root <code>db</code> directory. 
      </p>
      			
      <p>As we work on project development, you may find that you want to upload your own collection
         of XML files into eXist, and we’ll walk you through how to do that. This is different
         from uploading files to publish on your web space, which makes them publicly viewable
         but doesn’t build index files or let you collect, extract, and remix your coding using
         XQuery. 
      </p>
      		  
      <h3>XQuery for a Single Document vs. a Collection:</h3>
      			
      <p>XQuery uses XPath expressions to find its way through its index of files. It can work
         on one file, or on a whole collection, thus:
      </p>
      			
      <ul>
         
         <li>The <code>doc()</code> function in XQuery finds a single document, and inside the parentheses goes the path
            to the document within the database, including the filename. To retrieve our Georg
            Forster XML file, use: <code>doc('/db/pacific/voyages/ForsterGeorgComplete.xml')</code> . <br /><br /> 
         </li>
         
         <li>The <code>collection()</code> function finds a directory (or collection) that holds XML files. We’ve uploaded two
            other voyage files to sit in the same collection with our Georg Forster file, and
            we can run a  query of the ENTIRE group of files, instead of looking through each,
            one by one. To query this collection of files, we use <code>collection('/db/pacific/voyages')</code>.<br /><br /> 
         </li>
         
         <li>To return a complete single document so you can browse through its coding and structure,
            write an expression in this form: 
            <code>doc('/db/pacific/voyages/ForsterGeorgComplete.xml')/* </code>  
    <p>Enter this code, click on the <strong><q>Eval</q></strong> button at the top of the eXide interface, and see what happens in the return window. You should see the complete XML text of the Georg Forster Pacific voyage narrative.</p>
            
         </li>
         
         <li>Try accessing other files in this same <code>voyages</code> collection space: 
            <pre><code>HwksV2Ch4-8PNum.xml</code> and <code>cookVoy2Pnum.xml</code></pre>
            
         </li>
         
         <li>To write comments (or <q>comment out</q> some lines in XQuery), use <code>(: comment :) </code></li>
         
      </ul>
      
      
      <p>Actually, both <code>doc()</code> and <code>collection()</code> are XPath functions, and we’ll be adding more XPath, once you’ve designated the document
         or collection: You can write Xpath expressions, use predicates, functions, and walk up and down axes. This works if the files in your collection are coded (at least structurally)
         in the same or similar ways.
      </p>
      
      <h3>The TEI and XQuery: Declaring the TEI Namespace</h3>
      
      <p>Speaking of coding in the same or similar ways, we need to introduce you to the Text
         Encoding Initiative, or TEI. This a language of XML with designated rules and tag
         sets for coding digital versions of literary, linguistic, historical, and cultural
         texts, and it represents an international standard for coding work consistently for
         long-term, sustainable archives. TEI is also a community
         and people (like me) serve on its Technical Council to make judgment calls on best practices and
         coding guidelines. We use TEI to build digital archives that can "talk to" each other
         around the world, and follow recognizable, standard patterns. We <em>could</em> make up our
         own XML tag sets, but when coding cultural resources, it’s a good idea to make your
         work accessible, so it is easy for others to access and, say, load into databases to
         run XQuery for analyzing it, or studying it, or connecting it with other comparable
         texts in other archives! We’ll talk more about TEI structure and coding, and give
         you some experience with it. (To read more, <a href="http://www.tei-c.org/index.xml">here’s the TEI’s home site</a>.) For now, you can quickly tell if one of our files is coded in TEI from its root
         element: <code>&lt;TEI&gt;</code> .
      </p>
      
      <p>XQuery requires a <strong>namespace declaration</strong> when we use the TEI in order to properly follow its index and in order to follow
         the schema rules for TEI (to determine if your file is <dfn>valid</dfn> as a TEI document). Similarly, we also use a namespace declaration for HTML, to say there
         are certain rules governing the relationship of tags, their organization, etc.  When
         we query our TEI files, we’ll need to include the following namespace declaration
         as the first statement of our XQuery:</p> 
     <pre><code>declare default element namespace "http://www.tei-c.org/ns/1.0";</code></pre>
      
      <p>Following are examples of some XQuery expressions on collections of TEI files in our eXist database. Try copying them into the eXide window and running them by clicking on the <strong><q>Eval</q></strong> button. Notice the results you return with each.</p>
      
 <ol>     <li><pre><code>declare default element namespace "http://www.tei-c.org/ns/1.0";
            collection('/db/pacific/literary')//titleStmt/title</code></pre>
      <p>The above expression accesses a collection of files, the literary texts associated with our <a href="http://pacific.pitt.edu">Pacific voyages</a> project. It starts at the root of the eXist directory, always named <q>db</q> and steps down into a collection named <q>pacific</q>, and into a collection-inside-the-collection called <q>literary</q>. (There are a couple of other collections inside the <q>pacific</q> collection, named <q>voyages</q> and <q>mapping</q>, and you can access these collections by inputting their names in the appropriate directory path step inside the <code>collection()</code> function. Notice that after the <code>collection()</code> function, we are stepping down the XPath descendant axis with <code>//</code> and peering into two standard TEI elements that sit in a nested relation to one another. In the TEI header there must always be a <code>&lt;titleStmt&gt;</code> element, and it must contain a <code>&lt;title&gt;</code> element that is understood to be the title of the XML document. (You can use the <code>&lt;title&gt;</code> element elsewhere in a TEI document to mark titles of anything, say references in the document to other books, works of art, etc), but the <code>&lt;title&gt;</code> inside the <code>&lt;titleStmt&gt;</code> has a special function of identifying the title of the XML file itself. So, looking at your output you should see a list of those special <code>&lt;title&gt;</code> elements, which helps us to view at a glance the contents of a TEI collection like this. Stepping down the tree helps us to isolate just the piece of it that we want to return when we run (or <q>eval</q>) the XQuery code. </p></li>
      
     <li> <pre><code>declare default element namespace "http://www.tei-c.org/ns/1.0";
            collection('/db/pacific/literary')/distinct-values(.//body//persName)</code></pre>
        <p>This XQuery illustrates the use of an XPath function, <code>distinct-values()</code>, so that we will return a list gathered from across <em>the entire </em>of the distinctly different names of people (indicated by the TEI <code>&lt;persName&gt;</code> element) referenced within the <code>&lt;body&gt;</code> portion of the document. (In the TEI, much like in HTML, the <code>&lt;body&gt;</code> is a major top-level structure in the text's hierarchy and typically contains a text, like in this case, the full text of a poem, novel, or play. Other parts of the TEI text include a header or <dfn>metadata</dfn>, or information <em>about</em> the document, such as its title (up in the <code>&lt;titleStmt&gt;</code> and publication data.) Here, we want to you to notice <em>how we positioned the <code>distinct-values()</code> function</em>: Notice that we have to keep the <code>collection()</code> function outside of <code>distinct-values()</code>, once we are <em>inside</em> the collection, we take distinct values, using <strong>the dot (<code>.</code>)</strong> which means (as it always does in XPath), <code>the self::* axis</code>. If you try running this query without the dot, the function will lake the precise context it needs to understand its starting point. The dot (or self axis)  refers to the collection as a whole.</p>
     
     
     </li></ol>
      
      <h3><a id="FLWOR"></a><q>FLWOR</q> Expressions in XQuery
      </h3>
      
      <p><q>Flower</q> or FLWOR expressions are a powerful tool in XQuery, letting us work in more
         complex ways with querying and remixing information in files and collections—sometimes
         both in the same expression! Here's a primer on FLWOR (or really, LFWOR!):
      </p>
      
      
      <ul>
         <li><code>Let:</code> establishes variables which may be single values or arrays of multiple values (single
         or multiple)</li>
      
        <li> <code>For:</code> establishes a <i>range variable</i> that moves step by step from one value to the next and the next in a long list of
         values defined by a a Let statement. (single ONLY)</li>
     
         <li><code>Where</code> (optional): filtering; analogous to predicates</li>
         <li><code>Order by</code> (optional): alphabatize, etc. Always appears after a <code>Where</code> statement</li>
        
         <li><code>Return</code>: generates output</li>          
      </ul>
      
      
   <h4>A really, really simple little FLWOR</h4>
      
      <pre><code> let $hamlet := doc('/db/shakespeare/plays/hamlet.xml')
            return $hamlet   </code></pre>
      
      <h4>Examples of two related FLWOR Expressions, to demonstrate <code>For</code> and <code>Where</code> statements</h4>
      
      
    <ol>  <li>No <code>For</code> statement here):
         <pre><code>
            declare default element namespace "http://www.tei-c.org/ns/1.0";
            let $cook := doc('/db/pacific/voyages/cookVoy2Pnum.xml')
            let $p := $cook//p[geo]
            let $geo := $cook//p/geo
            let $countlat := count ($geo[@select="lat"])
            let $countlon := count ($geo[@select="lon"])
            where $countlat gt $countlon
            return $p</code></pre></li>
      
      <li>Using a "For" statement, with an XQuery comment.<br/> 
         Note; An XQuery comment is formatted inside <q>smiley faces</q> <code>(: your comment here :)</code>

         <pre><code>declare default element namespace "http://www.tei-c.org/ns/1.0";
            let $cook := doc('/db/pacific/voyages/cookVoy2Pnum.xml') 
            let $P := $cook//p[geo]
            let $geo := $cook//p/geo
            let $countlat := count ($geo[@select="lat"])
            let $countlon := count ($geo[@select="lon"])
            <strong>for $p in $P </strong> </code>
         (: To show the use of a range variable with <code>for</code>, try commenting this last line out, and changing the return expression to give <code>$P/@n</code> :)
         <code>
            where $countlat gt $countlon
            return string-join(('paragraph',$p/@n),': ') 
            </code> 
         
         (: Note use of the string-join function, with its separator. Also notice which parts
         of it take the <b>single-quotes</b> <code>' '</code>, and which parts don't! The single quotes,  <code>' '</code> , allow you to indicate you want some literal text to be returned here. Without it,
         the computer thinks you are referring to an XPath expression. :) </pre>
         
      </li></ol> 
      
      <h4 id="Order">The <q>O</q> in the FLWOR: <code>Order</code></h4>
         <p>The <code>Order</code> statement in the FLWOR is optional, but when you use it, it must follow
         a <code>Where</code> statement and immediately precede the <code>Return</code>. One of the standard, default uses of <code>Order</code> is to sort a list
         of results in alphabetical order, so, for example:
      </p>
      
      <pre><code>order by $a </code></pre>
      
      <p>organizes results in alphabetical order sorted by the whatever is indicated in the
         variable $a.</p>
         <p>There are more complex ways to set up an <code>Order</code> statement to organize results. For example, you can <q>order
         by descending</q> to get reverse alphabetical order:</p> 
      <pre><code>order by $a descending</code></pre>  
         <p>Or order a set results according to their numerical position or count, in ascending
         or descending order.
      </p>
      
      <h3 id="Curly">Building New HTML or XML with XQuery: Using Curly Braces: <code>{ }</code></h3>
      
      <p>To add HTML or XML markup to the XQuery output, add the elements where needed to produce
         conformant code. However, these elements are passive, or non-functional  when executing
         XQuery commands. So we use curly-braces<code> { } </code>to enclose any XPath or XQuery statements that we want to execute in XQuery, to separate
         them from the HTML or XML markup elements. Inside html elements, when we need to do
         some calculation or refer to a variable we defined in XQuery, we use the curly-braces
         again. We'll work on some examples in class. Here is one example that may be helpful
         as a reference point, showing how to make an HTML page with a table of two columns,
         making a list of two related variable results side by side. The resulting html file
         is coded to display a table of the distinct characters (&lt;SPEAKERS&gt;)in <i>Hamlet</i> from our Shakespeare collection, next to a count of their speeches (&lt;SPEECH&gt;) in
         the play. We have highlighted the position of the curly-braces in the example:
      </p>
      
      <pre>&lt;html&gt;
         &lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;
         &lt;body&gt;
         &lt;table&gt;
         
         <code>{</code>
         let $hamlet := doc('/db/shakespeare/plays/hamlet.xml')
         let $speeches := $hamlet//SPEECH
         let $speakers := $hamlet//SPEAKER
         
         let $distinctsp := distinct-values($speakers)
         for $sp in $distinctsp
         let $count := count($speeches[SPEAKER = $sp])
         order by $count descending
         return
         
         &lt;tr&gt;
         &lt;td&gt;<code>{$sp}</code>&lt;/td&gt;
         &lt;td&gt;<code>{$count}</code>&lt;/td&gt;
         &lt;/tr&gt;
         <code>}</code>
         &lt;/table&gt;
         
         &lt;/body&gt;
         &lt;/html&gt;
      </pre>
      <p>Here’s what’s happening when we apply the curly braces <code>{ }</code>. These wrap the portion of our code <em>in which XQuery must be processed</em>. We write the basic structural HTML tags: the <code>HTML</code>, <code>head</code>, and <code>body</code> elements to encircle our FLWOR statement, since these do not require any special XQuery processing and just need to be output to create a well-formed and valid HTML document. We then encircle the whole FLWOR statement inside curly braces, and when you write this in the eXide window, you will notice that if you <strong>remove</strong> those curly braces and hit the <strong><q>Eval</q></strong> button, the XQuery code is simply output as text (and appears all the same color as the HTML documents). When you apply the curly braces, eXide applies color to show you the XQuery code is active. So, why do we need <em>a second set of curly braces</em> inside our return statement, where we output a <code>&lt;p&gt;</code> element? Try removing them and look at your output! The answer has to do with the use of HTML (or other nonXQuery markup code, such as XML or KML, etc) in our output: The computer parser requires the curly braces <strong>any time you are representing the contents of an angle-bracketed element</strong>, so that it can tell when a string of text inside the angle-bracketed tags is a literal text string (no curly braces) or XQuery code to be processed (nested within curly braces). 
      </p>    
      <h3 id="Strings">Applying XPath string functions to control output in XQuery
      </h3>
      <p>Our model for the next two examples is drawn from Obdurodon’s <a href="http://dh.obdurodon.org/shakespeare-characters.html"><q>Generating a list of characters from a collection of Shakespeare plays in alphabetical order</q></a>. We have uploaded the same Shakespeare collection into our eXist database, so that these queries should work for you to run and explore the results.</p>
      
      <h4>1. Returning a <code>concatenated string</code> of results in plain text:</h4>
         <p>To follow this example, you should review the string functions in XPath, so <strong>see part III on Strings</strong> in Obdurodon’s <a href="http://dh.obdurodon.org/functions.xhtml">
            The XPath functions we use the most</a>.</p>
      
      
      
      <pre><code>let $hamlet := doc('/db/shakespeare/plays/hamlet.xml')
            let $speakers := distinct-values($hamlet//SPEAKER) 
            for $speaker in $speakers
            let $speakerLength := string-length($speaker)
            where ends-with($speaker,'O')
            (:order by string-length($speaker):)  (:commenting out! :)
            order by $speakerLength
            
            (:return $speaker:) (:commenting out! :)
            return concat ($speaker, ' has ', $speakerLength , ' characters')</code>
         
      </pre>
      
      <h4>2. Insert HTML formatting around the FLOWR statement to turn the results into a web page</h4> 
         <p>Notice the positioning of two pairs of curly braces <code>{ }</code> in this XQuery code:</p>
       
       <pre>  &lt;html&gt;
         &lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;
         &lt;body&gt; <code>{</code>
            let $hamlet := doc('/db/shakespeare/plays/hamlet.xml')
            let $speakers := distinct-values($hamlet//SPEAKER)
            for $speaker at $pos in $speakers                                           
            (: The above line creates a special variable named $pos that identifies the position value of each speaker in the list of all the distinct speakers :) 
            let $speakerLength := string-length($speaker)
            where ends-with($speaker,'O')
            order by $speakerLength
            return 
            &lt;p&gt;<code>{</code>concat ($speaker, '#', $pos, ' has ', $speakerLength , ' characters')<code>}</code>&lt;/p&gt;
           <code>}</code>
          &lt;/body&gt;  
          &lt;/html&gt;
       </pre>
     
      <h3>Namespaces and XQuery output formats</h3>
 <p>While we frequently write XQuery to output plain text or HTML, we can also write it to produce output code in a namespace, such as specialized forms of XML like TEI or KML. Watch this space for details as we develop this portion of the tutorial. <!--2016-03-02 ebb: DEVELOP THIS SECTION! -->
 </p>     
      <h3>Links to Some Excellent XQuery Resources:</h3>
      
      <ul>
         
         <li><a href="http://en.wikibooks.org/wiki/XQuery">XQuery Wikibook</a>: Some examples here are specific to working in eXist, and some are in more general
            usage.
         </li>
         
         <li><a href="http://www.xquery.com/tutorials/guided-tour/">XQuery: A Guided Tour</a>, and especially <a href="http://www.xquery.com/tutorials/guided-tour/combine-restructure-nodes.html">their discussion of FLWOR expressions</a>.
         </li>
         
         
      </ul>
      					
      	
   </body>
   
   
   
   
</html>