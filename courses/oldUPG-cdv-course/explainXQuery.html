
<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml">
   
   	
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      <link rel="stylesheet" type="text/css" href="explain.css" />
      <title>XQuery and eXist</title>
   </head>
   
   
   
   <body>
      <!--#include virtual="top.html" -->
      		
      		  
      <h1><span class="banner">XQuery and the eXist XML Database</span></h1>
      		  
      		  
      		  
      			
      			
      <h3>What’s an XML database and how does it work? </h3>
      			
      <p>XQuery is one of the XML family of languages that builds on what you have learned of XPath, and we use it to work with <dfn>XML databases</dfn>. XML
         databases basically work by storing XML files and building <q>persistent indexes</q> for
         them—and this indexing capacity makes it speedy and efficient to search for elements,
         attribute values and calculate functions (anything you can locate and process with XPath expressions) across
         collections of files. XML databases can run speedily because they build an <dfn>index</dfn> of each file, so that the computer doesn’t have to review the entire file every time you run XQuery code. Basically the database’s index stores the tree structure of XML in the database memory, and makes it available for quick retrieval through XQuery. 
      </p>
      			
      <h3>How to Access our eXist XML database: </h3>
      			
      <p>We are working with a particular XML database called eXist-db, which we have installed on the NewtFire server. Usually when we work on homework exercises and on project development, we will be working on our NewtFire eXist installation, but we can also write and run XQuery locally inside &lt;oXygen/&gt; by clicking on the little <q>XQuery Debugger</q> button right next to the <q>XSLT debugger</q> button in the top right of the &lt;oXygen/&gt; window to work with a batch of files we have saved locally. For our projects we tend to prefer working with an eXist installation either on a server or offline on a local computer because a) eXist has indexing tools that we use to make it more efficient to run over multiple collections stored on a remote server, and b) we can connect the XQuery scripts and XML files we have stored in eXist to our project websites. Here’s how to access our NewtFire eXist database:</p>
      	<ol>
      	   <li>In a web browser, go to <a href="http://newtfire.org:8338/">http://newtfire.org:8338/</a></li>
      	   <li>Wait for eXist to load, and it will show you a page of several icons/images.</li>
      	   <li>Look for the eXide button in the second row of icons and click on it. An interface will open where you can input XQuery code and work with the collections of files we have stored here.</li>
      	   <li>For our first assignments, a login is not strictly necessary, but as you work on projects or if you wish to save your XQuery code to a directory you create here, you will need to log in with a username and password. If you are an enrolled student in one of my digital humanities courses, I will likely have created a login for you, and for details please see Courseweb.</li>
      	   <li>If you save an XQuery script to the database, give it a file extension to identify it as XQuery: <code>filename.xql</code> or <code>filename.xquery</code>. Note: You can also write XQuery in &lt;oXygen/&gt; to query a document or collection on your local computer: Open a new XQuery file from File -> New, and you will notice that &lt;oXygen/&gt; uses the <code>.xquery</code> extension.</li>
      	</ol>  
      		  
      		  
      <!--2016-03-01 ebb: OLD MODE OF ACCESS from 2013
         <p>eXist is available right now in two "places", in the same way you access our Digital
         Sandbox for developing your project websites:
      </p>
      		  
      <ol>
         <li>In our campus computer labs, without an sremote login: <a href="http://x1.digital.greensburg.pitt.edu:8080/exist/apps/dashboard/index.html       ">http://x1.digital.greensburg.pitt.edu:8080/exist/apps/dashboard/index.html</a><br /></li>
         
         <li>On your OWN computers with a wireless or wired connections. (Please test this ASAP
            following the instructions below to make sure it works for you.)
         </li>       
         
      </ol>
      	      
      <p>To begin, you need to use the secure login, "Network Connect"-\-our private passageway
         to eXist. If you’re enrolled in this class, you’ve been granted access. Here’s what
         to do: 
      </p>
      
      <ol>
         
         <li>Open <b>Internet Explorer</b> or <b>Firefox</b>, and go to <a href="http://sremote.pitt.edu">http://sremote.pitt.edu</a> . (Network Connect won’t be fully functional in other browsers.) If you can’t get
            in through Explorer, try the Firefox browser.
         </li>
         
         <li>With "Network Connect" selected, log in with your Pitt userid and password (the same
            that you use for e-mail and for your Pitt web space)
         </li>
         
         <li>After you log in, you’ll see a link to <b>"Firewall-GBG-DH-DIGITAL-SANDBOX-NetworkConnect."</b> Click on this to bring up a new screen with the words "Network Connect" again-\-this
            time with a "Start" button. <b>Click on the Start Button, and wait</b> until Network Connect seems to have run.
         </li>
         
         <li>Once you’ve done this, you may open ANY web browser (or a new tab in this browser)
            and go to this link to our eXist XML database:<br /><b><a href="http://x1.digital.greensburg.pitt.edu:8080/exist/apps/dashboard/index.html ">http://x1.digital.greensburg.pitt.edu:8080/exist/apps/dashboard/index.html</a></b>
            
         </li>
         
         <li>Here, you may log in locally with:
            
            <ul>
               
               <li>id: your Pitt userid </li>
               
               <li>password: dhclass </li>
               
            </ul>
            <br />
            (After you log in for the first time, change the password to whatever you want.) 
            
         </li>
         
         <li>Open <b>eXide</b> to work on XQuery. 
         </li>
         
         
      </ol>
      -->
      
     
      
      <h3>How the database is organized: </h3>
      			
      <p>eXist holds file directories, or <dfn>collections</dfn> in a hierarchical structure, so that you can access and query a collection of XML files all together. You might think of a collection as one giant XML file with subfiles inside, so you can step up and down the file directory structure with XPath just as you step up and down the XML element hierarchy in the parent/ancestor and child/descendant axes within a single XML document. In the eXist database there is a single root directory called <strong><code>db</code></strong>, with subfolders containing folders (or collections), which may in turn contain their
         own subfolders (more collections), and finally files. I’ve installed a copy of our
         Georg Forster XML file here, in a collection called <q>voyages</q>, inside a directory
         called <q>pacific</q>, and that means that its address in our database is <code>/db/pacific/voyages/ForsterGeorgComplete.xml</code>, starting from the root <code>db</code> directory. 
      </p>
      			
      <p>As we work on project development, you may find that you want to upload your own collection
         of XML files into eXist, and we’ll walk you through how to do that. This is different
         from uploading files to publish on your web space, which makes them publicly viewable
         but doesn’t build index files or let you collect, extract, and remix your coding using
         XQuery. 
      </p>
      		  
      <h3>XQuery for a Single Document vs. a Collection:</h3>
      			
      <p>XQuery uses XPath expressions to find its way through its index of files. It can work
         on one file, or on a whole collection, thus:
      </p>
      			
      <ul>
         
         <li>The <code>doc()</code> function in XQuery finds a single document, and inside the parentheses goes the path
            to the document within the database, including the filename. To retrieve our Georg
            Forster XML file, use: <pre><code>doc('/db/pacific/voyages/ForsterGeorgComplete.xml')</code></pre> . 
         </li>
         
         <li>The <code>collection()</code> function finds a directory (or collection) that holds XML files. We’ve uploaded two
            other voyage files to sit in the same collection with our Georg Forster file, and
            we can run a  query of the ENTIRE group of files, instead of looking through each,
            one by one. To query this collection of files, we use <pre><code>collection('/db/pacific/voyages')</code></pre>.
         </li>
         
         <li>To return a complete single document so you can browse through its coding and structure,
            write an expression in this form: 
            <pre><code>doc('/db/pacific/voyages/ForsterGeorgComplete.xml')/* </code></pre>  
    <p>Enter this code, click on the <strong><q>Eval</q></strong> button at the top of the eXide interface, and see what happens in the return window. In the Return Window, notice that you have options for setting and formatting the output: to view the XML code, you need to have <q>XML Output</q> selected. You should see the complete XML text of the Georg Forster Pacific voyage narrative in the output window. (Note: You can also set <q>Live Query</q> to automatically run and update your results as you are typing XQuery. We do not typically use this since it seems to introduce lag in typing in the eXide window, but your experience may vary from ours. Experiment! You can also click to move the output window to the side instead of bottom of the screen.)
    </p>
            
         </li>
         
         <li>Try accessing other files in this same <code>voyages</code> collection space: 
          <code>HwksV2Ch4-8PNum.xml</code> and <code>cookVoy2Pnum.xml</code>. Note: you can also browse through the XML code of all the files in the collection at once with:
            <pre><code>collection('/db/pacific/voyages')/*</code></pre>
            
         </li>
      
         
         <li>To write comments (or <q>comment out</q> some lines in XQuery), use <code>(: comment :) </code></li>
         
      </ul>
      
      
      <p>Actually, both <code>doc()</code> and <code>collection()</code> are XPath expressions (<code>doc()</code> reaches for an XML document node and the <code>collection()</code> function retrieves a collection of document nodes). We’ll be adding more XPath once you’ve designated the document
         or collection: You can write Xpath expressions, use predicates, functions, and walk up and down axes. Your XPath expressions will locate results from all the files in a collection as long as those files are coded (at least structurally)
         in the same or similar ways.
      </p>
      
      <h3>The TEI and XQuery: Declaring the TEI Namespace</h3>
      
      <p>Speaking of coding in the same or similar ways, we need to introduce you to the Text
         Encoding Initiative, or TEI. This a language of XML with designated rules and tag
         sets for coding digital versions of literary, linguistic, historical, and cultural
         texts, and it represents an international standard for coding work consistently for
         long-term, sustainable archives. TEI is also a community
         and people (like me) serve on its Technical Council to make judgment calls on best practices and
         coding guidelines. We use TEI to build digital archives that can "talk to" each other
         around the world, and follow recognizable, standard patterns. We <em>could</em> make up our
         own XML tag sets, but when coding cultural resources, it’s a good idea to make your
         work accessible, so it is easy for others to access and, say, load into databases to
         run XQuery for analyzing it, or studying it, or connecting it with other comparable
         texts in other archives! We’ll talk more about TEI structure and coding, and give
         you some experience with it. (To read more, <a href="http://www.tei-c.org/index.xml">here’s the TEI’s home site</a>.) For now, you can quickly tell if one of our files is coded in TEI from its root
         element: <code>&lt;TEI&gt;</code> .
      </p>
      
      <p>XQuery requires a <strong>namespace declaration</strong> when we use the TEI in order to properly follow its index and in order to follow
         the schema rules for TEI (to determine if your file is <dfn>valid</dfn> as a TEI document). Similarly, we also use a namespace declaration for HTML, to say there
         are certain rules governing the relationship of tags, their organization, etc.  When
         we query our TEI files, we’ll need to include the following namespace declaration
         as the first statement of our XQuery:</p> 
     <pre><code>declare default element namespace "http://www.tei-c.org/ns/1.0";</code></pre>
      
      <p>Following are examples of some XQuery expressions on collections of TEI files in our eXist database. Try copying them into the eXide window and running them by clicking on the <strong><q>Eval</q></strong> button. Notice the results you return with each.</p>
      
 <ol>     <li><pre><code>declare default element namespace "http://www.tei-c.org/ns/1.0";
            collection('/db/pacific/literary')//titleStmt/title</code></pre>
      <p>The above expression accesses a collection of files, the literary texts associated with our <a href="http://pacific.pitt.edu">Pacific voyages</a> project. It starts at the root of the eXist directory, always named <q>db</q> and steps down into a collection named <q>pacific</q>, and into a collection-inside-the-collection called <q>literary</q>. (There are a couple of other collections inside the <q>pacific</q> collection, named <q>voyages</q> and <q>mapping</q>, and you can access these collections by inputting their names in the appropriate directory path step inside the <code>collection()</code> function. Notice that after the <code>collection()</code> function, we are stepping down the XPath descendant axis with <code>//</code> and peering into two standard TEI elements that sit in a nested relation to one another. In the TEI header there must always be a <code>&lt;titleStmt&gt;</code> element, and it must contain a <code>&lt;title&gt;</code> element that is understood to be the title of the XML document. (You can use the <code>&lt;title&gt;</code> element elsewhere in a TEI document to mark titles of anything, say references in the document to other books, works of art, etc), but the <code>&lt;title&gt;</code> inside the <code>&lt;titleStmt&gt;</code> has a special function of identifying the title of the XML file itself. So, looking at your output you should see a list of those special <code>&lt;title&gt;</code> elements, which helps us to view at a glance the contents of a TEI collection like this. Stepping down the tree helps us to isolate just the piece of it that we want to return when we run (or <q>eval</q>) the XQuery code. </p></li>
      
     <li> <pre><code>declare default element namespace "http://www.tei-c.org/ns/1.0";
            collection('/db/pacific/literary')/distinct-values(descendant::body//persName)</code></pre>
        <p>This XQuery illustrates the use of an XPath function, <code>distinct-values()</code>, so that we will return a list gathered from across <em>the entire </em>of the distinctly different names of people (indicated by the TEI <code>&lt;persName&gt;</code> element) referenced within the <code>&lt;body&gt;</code> portion of the document. (In the TEI, much like in HTML, the <code>&lt;body&gt;</code> is a major top-level structure in the text's hierarchy and typically contains a text, like in this case, the full text of a poem, novel, or play. Other parts of the TEI text include a header or <dfn>metadata</dfn>, or information <em>about</em> the document, such as its title (up in the <code>&lt;titleStmt&gt;</code> and publication data.) Here, we want to you to notice <em>how we positioned the <code>distinct-values()</code> function</em>: Notice that we have to keep the <code>collection()</code> function outside of <code>distinct-values()</code>, once we are <em>inside</em> the collection, we take distinct values, using <strong>the dot (<code>.</code>)</strong> which means (as it always does in XPath), <code>the self::* axis</code>. If you try running this query without the dot, the function will lake the precise context it needs to understand its starting point. The dot (or self axis)  refers to the collection as a whole.</p>
     
     
     </li></ol>
      
      <h3><a id="FLWOR"></a><q>FLWOR</q> Expressions in XQuery
      </h3>
      
      <p><q>Flower</q> or FLWOR expressions are a powerful tool in XQuery, letting us work in more
         complex ways with querying and remixing information in files and collections—sometimes
         both in the same expression! Here's a primer on FLWOR (or really, LFWOR!):
      </p>
      
      
      <ul>
         <li><code>Let:</code> establishes variables which may be single values or arrays of multiple values (single
         or multiple)</li>
      
        <li> <code>For:</code> establishes a <strong><dfn>range variable</dfn></strong> that moves step by step from one value to the next and the next in a long list of
         values defined by a Let statement. The <dfn>range variable</dfn> is designed to process and return a single value at a time, and we say that it <q><em>loops through</em></q> a list of multiple values.</li>
     
         <li><code>Where</code> (optional): filtering; analogous to predicates</li>
         <li><code>Order by</code> (optional): alphabatize, etc. If you use it with a <code>Where</code> statement, <code>Order by</code> always has to appear after Where. Always appears after a <code>Where</code>.</li>
        
         <li><code>Return</code>: generates output</li>          
      </ul>
      
      
   <h4>A really, really simple little FLWOR</h4>
      
      <pre><code> let $hamlet := doc('/db/shakespeare/plays/hamlet.xml')
            return $hamlet   </code></pre>
      
      <h4>Another simple FLWOR: processing a collection of files to return information from a single document</h4>
      <p>Here is an example to demonstrate how we can start with a variable defining a collection of files, and reach into it to retrieve information from a particular special file inside. 
      <strong>Note:</strong> this particular collection, our Pacific voyage collection, is in the <strong>TEI namespace</strong>, so we require a special namespace declaration line.</p>
      
     
      <pre>
      declare default element namespace "http://www.tei-c.org/ns/1.0";
      let $pacific := collection('/db/pacific/voyages')/*
      let $GeorgFile := $pacific<code>[descendant::author[contains(., 'Georg')]]</code>//titleStmt/title
      return $GeorgFile
      </pre>
     
      
      <p>This returns just one result in the eXide output window:</p>
     
      <pre>
       1
      &lt;title xmlns="http://www.tei-c.org/ns/1.0"&gt;A Voyage Round the World in His Majesty's Sloop, Resolution, commanded by Capt. James Cook, 
      during the Years 1772, 3, 4, 5.&lt;/title&gt;
      </pre>
     
      <p> Notice how we referenced the <code>descendant::</code> axis in our XQuery FLWOR. We could also have used <code>.//</code> to indicate the <code>self::</code> axis, but we must NOT use <code>//</code>. We require the dot or the indication of the <code>descendant::</code> axis in the variable <code>$GeorgFile</code> to set a starting point, to indicate that we are <em>stepping down</em> from the position defined by the <code>$pacific</code> variable. (If we do not use the dot, we return zero results because the starting position of the XPath in the predicate is unclear to the computer parser! Try it yourself and see what happens.) </p>
      
      
      <h4>Examples of two related FLWOR Expressions, to demonstrate <code>Where</code> and <code>For</code> statements</h4>
      
      
    <ol>  <li>No <code>For</code> statement here):
         <pre>declare default element namespace "http://www.tei-c.org/ns/1.0";
            let $cook := doc('/db/pacific/voyages/cookVoy2Pnum.xml')
            let $p := $cook//p[geo]
            let $geo := $cook//p/geo
            let $countlat := count ($geo[@select="lat"])
            let $countlon := count ($geo[@select="lon"])
            where $countlat gt $countlon
            return $p</pre>
    </li>
      <li>Using a <code>For</code> statement, with an XQuery comment.<br/> 
         Note: An XQuery comment is formatted inside <q>smiley faces</q> like this: <code>(: your comment here :)</code>

         <pre>declare default element namespace "http://www.tei-c.org/ns/1.0";
            let $cook := doc('/db/pacific/voyages/cookVoy2Pnum.xml') 
            let $Paras := $cook//p[geo]
            let $geo := $cook//p/geo
            let $countlat := count ($geo[@select="lat"])
            let $countlon := count ($geo[@select="lon"])
            <strong>for $p in $Paras</strong> 
            where $countlat gt $countlon
            return string-join(('paragraph',$p/@n),': ') 
             
         (: Note use of the string-join function, with its separator. Also notice which parts
         of it take the <b>single-quotes</b> <code>' '</code>, and which parts do not! The single quotes,  <code>' '</code> , allow you to indicate 
that you want some literal text to be returned here. Without it, the computer thinks you are referring to an XPath expression. :) </pre>
         
      </li></ol> 
      
      <h4 id="Order">The <q>O</q> in the FLWOR: <code>Order</code></h4>
         <p>The <code>Order</code> statement in the FLWOR is optional, but when you use it, it must follow
         a <code>Where</code> statement and immediately precede the <code>Return</code>. One of the standard, default uses of <code>Order</code> is to sort a list
         of results in alphabetical order, so, for example:
      </p>
      
      <div class="code"><code>order by $a</code> </div>
      
      <p>organizes results in alphabetical order sorted by the whatever is indicated in the
         variable <code>$a</code>.</p>
         <p>There are more complex ways to set up an <code>Order</code> statement to organize results. For example, you can <q>order
         by descending</q> to get reverse alphabetical order:</p> 
      <div class="code"><code>order by $a descending</code></div>  
         <p>Or you can order a set results according to their numerical position or count, in ascending or descending order.
      </p>
      
      <h3 id="Curly">Building New HTML or XML with XQuery: Using Curly Braces: <code>{ }</code></h3>
      
      <p>To add HTML or XML markup to the XQuery output, add the elements where needed to produce
         conformant code. However, these elements are passive, or non-functional  when executing
         XQuery commands. So we use curly-braces<code> { } </code>to enclose any XPath or XQuery statements that we want to execute in XQuery, to separate
         them from the HTML or XML markup elements. Inside html elements, when we need to do
         some calculation or refer to a variable we defined in XQuery, we use the curly-braces
         again. We’ll work on some examples in class. Here is one example that may be helpful
         as a reference point, showing how to make an HTML page with a table of two columns,
         making a list of two related variable results side by side. The resulting html file
         is coded to display a table of the distinct characters (&lt;speaker&gt; elements) in <i>Hamlet</i> from our Shakespeare collection, next to a count of their speeches (&lt;sp&gt;) in
         the play. Speeches in the play are coded in TEI like this, with speaker names entered as a child element. (Speaker identifiers are also coded as an attribute on the <code>sp</code> element. In the code below, we will simply work with the contents of the <code>speaker</code> element, but you could practice and see if you can adapt our example by changing it to work with the <code>@who</code> attribute instead.) </p>
         <pre>
&lt;sp xmlns="http://www.tei-c.org/ns/1.0" who="Francisco"&gt;
  &lt;speaker&gt;Francisco&lt;/speaker&gt;
  &lt;l xml:id="sha-ham101002" n="2"&gt;Nay, answer me: stand, and 
     unfold yourself.&lt;/l&gt;
&lt;/sp&gt;</pre>
<p>We have highlighted the position of the curly-braces in the example:
      </p>
      
      <pre>
      xquery version "3.1";
declare default element namespace "http://www.tei-c.org/ns/1.0";  
         &lt;html&gt;
         &lt;head&gt;&lt;title&gt;Speakers and counts of their 
         speeches in Hamlet&lt;/title&gt;&lt;/head&gt;
         &lt;body&gt;
         &lt;table&gt;
         
         <code>{</code>
         let $hamlet := doc('/db/apps/shakespeare/data/ham.xml')
         let $speeches := $hamlet//sp
         let $speakers := $hamlet//speaker
         let $distinctsp := distinct-values($speakers)
         for $sp in $distinctsp
         let $count := count($speeches[speaker = $sp])
         order by $count descending
         return
         
         &lt;tr&gt;
         &lt;td&gt;<code>{$sp}</code>&lt;/td&gt;
         &lt;td&gt;<code>{$count}</code>&lt;/td&gt;
         &lt;/tr&gt;
         <code>}</code>
         &lt;/table&gt;
         
         &lt;/body&gt;
         &lt;/html&gt;</pre>
      <p>Here’s what’s happening when we apply the curly braces <code>{ }</code>. These wrap the portion of our code <em>in which XQuery must be processed</em>. We write the basic structural HTML tags: the <code>HTML</code>, <code>head</code>, and <code>body</code> elements to encircle our FLWOR statement, since these do not require any special XQuery processing and just need to be output to create a well-formed and valid HTML document. We then encircle the whole FLWOR statement inside curly braces, and when you write this in the eXide window, you will notice that if you <strong>remove</strong> those curly braces and hit the <strong><q>Eval</q></strong> button, the XQuery code is simply output as text (and appears all the same color as the HTML documents). When you apply the curly braces, eXide applies color to show you the XQuery code is active. So, why do we need <em>a second set of curly braces</em> inside our return statement, where we output a <code>&lt;p&gt;</code> element? Try removing them and look at your output! The answer has to do with the use of HTML (or other nonXQuery markup code, such as XML or KML, etc) in our output: The computer parser requires the curly braces <strong>any time you are representing the contents of an angle-bracketed element</strong>, so that it can tell when a string of text inside the angle-bracketed tags is a literal text string (no curly braces) or XQuery code to be processed (nested within curly braces). 
      </p>    
      <h3 id="Strings">Applying XPath string functions to control output in XQuery
      </h3>
      <p>Our model for the next two examples is adapted from Obdurodon’s <a href="http://dh.obdurodon.org/shakespeare-characters.html"><q>Generating a list of characters from a collection of Shakespeare plays in alphabetical order</q></a>. Try testing and exploring the XQuery scripts below with our Shakespeare collection on the newtFire eXist-db.</p>
      
      <h4>1. Returning a <code>concatenated string</code> of results in plain text:</h4>
      <p>This example returns the characters in <i>Hamlet</i> whose names end with the letter “o”, and outputs the number of characters in their names. To follow this example, you should review the string functions in XPath, so <strong>see part III on Strings</strong> in Obdurodon’s <a href="http://dh.obdurodon.org/functions.xhtml">The XPath functions we use the most</a>.</p>
      
      <pre>xquery version "3.1";
     declare default element namespace "http://www.tei-c.org/ns/1.0";
     let $hamlet := doc('/db/apps/shakespeare/data/ham.xml')
     let $speakers := distinct-values($hamlet//speaker) 
     for $speaker in $speakers
     let $NameLength := string-length($speaker)
      where ends-with($speaker,'o')
       (:order by string-length($speaker):)  
          (:commenting out! :)
     order by $NameLength
         
       (:return $speaker:) (:commenting out! :)
     return concat ($speaker, ' has ', $NameLength , ' characters.')</pre>
      
      <h4>2. Insert HTML formatting around the FLOWR statement to turn the results into a web page</h4> 
         <p>Notice the positioning of two pairs of curly braces <code>{ }</code> in this XQuery code:</p>
       
       <pre>  &lt;html&gt;
         &lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;
         &lt;body&gt; <code>{</code>
            let $hamlet := doc('/db/apps/shakespeare/data/ham.xml')
            let $speakers := distinct-values($hamlet//speaker)
            for $speaker at $pos in $speakers                              
         (: The above line creates a special variable named $pos that
         identifies the position number of each speaker in the sequence of all the distinct speakers. We can use that position number in our output. :) 
        
            let $speakerLength := string-length($speaker)
            where ends-with($speaker,'o')
            order by $speakerLength
            return 
            &lt;p&gt;<code>{</code>concat ($speaker, '#', $pos, ' has ', $speakerLength , ' characters')<code>}</code>&lt;/p&gt;
           <code>}</code>
          &lt;/body&gt;  
          &lt;/html&gt;</pre>
     
      <h3>Namespaces and XQuery output formats</h3>
 <p>While we frequently write XQuery to output plain text or HTML, we can also write it to produce output code in a namespace, such as specialized forms of XML like TEI or KML. Above, when we were processing XQuery on a TEI file for the Pacific project, we used a convenient line of code at the top of the file:
 </p>    <pre>declare default element namespace "http://www.tei-c.org/ns/1.0";</pre>
      <p>Using this means that the default format of all elements being processed <em>and</em> output iwll be in TEI, and that was fine for our processing above. It may not be okay, though, when you need to process the special Wordhoard TEI Shakespeare collection to convert its TEI elements into HTML elements. Here we need to declare <em>two</em> namespaces, and we have to make a decision which one should be the default. The other one that isn't marked as the default will have to be distinguished, using a  <strong>namespace prefix</strong>, like this: <code>tei:text</code> (for the TEI element <code>&lt;text&gt;</code>). When transforming from TEI to HTML, we recommend setting the output HTML as the default namespace and treating TEI elements with prefixes (and generally speaking we suggest setting the namespace format of the output file as the default namespace in your XQuery code. Here is how to set a default namespace line and a namespace line that requires prefixes: </p>
      <pre>
         declare default element namespace "http://www.w3.org/1999/xhtml";
         declare namespace tei="http://www.tei-c.org/ns/1.0";
         (:Continue writing XQuery here... :)</pre>
      <p>The top line of our example above is a default element namespace line, which we're setting for our output format, the HTML namespace. (We found it by opening an HTML file in oXygen, and just pasted it in here.) The default element namespace won't require us to set prefixes, but if we want to be processing  code from a different namespace, we need to declare it too. The TEI elements being processed will all require the <code>tei:</code> prefix in front for the code to properly distinguish these elements. Note: Attributes are in no namespace at all, but their parent (hosting) elements are what is namespaced. That means you only need to use the namespace prefix on the element names, not the attributes.</p>    
      <h3>Links to Some Excellent XQuery Resources:</h3>
      
      <ul>
         
         <li><a href="http://en.wikibooks.org/wiki/XQuery">XQuery Wikibook</a>: Some examples here are specific to working in eXist, and some are in more general
            usage.
         </li>
         
         <li>Michael Kay’s <a href="http://www.stylusstudio.com/tutorials/xquery-tutorials.html">XQuery Tutorials</a>, and especially <a href="http://www.stylusstudio.com/xquery-flwor.html">their discussion of FLWOR expressions</a>.
         </li>
         
         
      </ul>
      					
      	
   </body>
   
   
   
   
</html>