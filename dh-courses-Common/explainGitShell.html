<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml">


    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" type="text/css" href="explain.css" />
        <title>Explain Git Shell</title>
    </head>



    <body>
        <!--#include virtual="topAuthorRJP43.html" -->
        <h1><span class="banner">Guide to Git Shell:</span></h1>
        <h2>operating Git using command line</h2>
        <div id="quickRef">
            <h3>Quick Reference:</h3> The Basics:<ul>
                <li><a href="#terms">Key Terms</a></li>
                <li><a href="#account">Getting Started</a></li>
                <li><a href="#repo">Repositories: Creating, Cloning, Adding Collaborators</a></li>
                <li><a href="#nav">Working With Directories</a></li>
                <li><a href="#issue">GitHub as Social Media: Issues and Wikis</a></li>
                <li><a href="#cheatSheet">Common Git Commands</a></li>
            </ul> Advanced Project Management: <ul>
                <li><a href="#trouble">Troubleshooting: Merge Conflicts and Bad Commits</a></li>
                <li><a href="#branch">Branches: Creating and Deleting</a></li>
                <li><a href="#fork">Forks: Creating and Maintaining</a></li>
            </ul>
        </div>
        <h3>What is Git? And why do we use it?</h3>
        <!-- RJP:2016-08-26: Needs edited to include more info about VCSs and what makes Git Different -->
        <p>Git is a free, open-source version control system (VCS) designed to handle everything
            from small tasks to major projects. The major difference between Git and any other VCS
            is the way Git thinks about its data. Conceptually, most other version control systems
                <span class="smaller">(Example: DropBox)</span> store information as a set of files
            with a means to reference the changes made to each file over time. Git, on the other
            hand, thinks of its data more like a set of snapshots of a miniature file system. Every
            time you commit, or save the state of your project in Git, it basically takes a picture
            of what all your files look like at that moment and stores a reference to that snapshot.
            To be efficient, if files have not changed, Git doesn’t store the file again, just a
            link to the previous identical file it has already stored. This aspect of Git makes the
            reliability of being able to revert back to an exact moment in a project, for any given
            file or the project in its entirety, much more stable than other VCSs.</p>
        <p>So let's say you and a team member are both updating the same XML document inside of your
            shared <dfn>repository</dfn>
            <span class="smaller">(directory of files)</span>. You make your changes, save them, and
            upload them back to the shared repository. So far, so good. The problem, for most VCSs,
            comes when your team member is working on the same document as you at the same time. One
            of you is about to have your work overwritten and erased; however, Git keeps that from
            happening. You and your fellow team member can each upload your revisions to the same
            document, and Git will save two versions of the file. If you both were working on
            different parts of the same document Git will automatically <dfn>merge</dfn> your
            changes together without losing any work along the way. If you both happen to edit the
            exact same segment of code Git will issue a <dfn>merge conflict</dfn> to point out where
            the two files differ allowing you and your team to decide what version to keep. You can
            even revert to an earlier version at any time, because Git keeps a <q>snapshot</q> of
            every change ever made by all project collaborators.</p>
        <p>Another great aspect of Git is the emphasis on local operation. Git doesn't need to go
            out to the server to get the history of a project and display it for you – it simply
            reads it directly from your local computer. This means you see the project history
            almost instantly, without having to wait for server network lag. This also means that
            there is very little you can't do if you're offline. When you manage a project using
            Git, you keep copies of all the project files on both your local machine and the online
            GitHub server. You work on your local machine, periodically <dfn>pushing</dfn> your
            changes onto the server so they'll be accessible to your project partners, and
            periodically <dfn>pulling</dfn> changes made by your project team from the server to
            your local machine. So as long as you have recently pulled in any changes you can work
            offline until you are ready to push your changes. For more information regarding what
            Git is and the benefits of using Git please visit the online version of <a
                href="http://git-scm.com/" target="_blank">Pro Git</a>, a how-to guide to Git.</p>
        <h4>Why use Git Shell (command line)?</h4>
        <p>Unlike the Graphical User Interfaces (GUIs), the command line / terminal is the only
            place you can take advantage of all the functions Git has to offer. The GUIs only
            implement the simplistic functionality of Git as a means to use Git at the most basic
            level. For most of you command line / terminal will be a foreign interface. Think of it
            as a way to navigate your computer's files and systems by typing commands (strings of
            text) at prompts, instead of using the mouse. Click <a
                href="http://try.github.io/levels/1/challenges/1" target="_blank">here</a> for
            GitHub's helpful, interactive tutorial on using the Git command-line interface.</p><!-- RJP:2016-08-24: Should we link to our GUI tutorial here? I think better not send students down a path we don't encourage. Just in case: http://dh.obdurodon.org/github.xhtml -->
        <h3 id="terms">Basic Terms to Understanding Git and GitHub</h3>
        <!-- RJP:2016-08-26: Needs edited to correspond with edits made in first few paragraphs -->
        <p>Below is a list of key terms you will need to understand while using Git and GitHub. Each
            of these terms will be discussed in greater detail throughout this tutorial, but think
            of this as your quick reference guide to the basics.</p>
        <ul style="list-style-type:none">
            <li><dfn><strong>Repository</strong></dfn> (repo): a project's folder. A repository
                contains all of the project files (including documentation), and stores each file's
                revision history. Repositories can have multiple collaborators and can be either
                public or private.</li>
            <li><dfn><strong>GitHub</strong></dfn>: web-based Git repository hosting service. It
                offers all of the distributed revision control and source code management (SCM)
                functionality of Git as well as its own social network features. This is the web
                interface for the remote, shared version of your project(s). Think of this as your
                projects' central hub where project collaborators are able to discuss development
                and share project files. <a href="https://github.com/" target="_blank"
                    >GitHub.com</a></li>
            <li><dfn><strong>Clone</strong></dfn>: a copy of a repository that lives on your
                computer instead of on GitHub's server, or the act of making that copy. With your
                clone you can edit the files in &lt;oXygen/&gt; and use Git to keep track of your
                changes without having to be online. It is, however, connected to the remote version
                so that changes can be synced between the two. You can push your local changes to
                the remote to keep them synced when you're online.</li>
            <li><dfn><strong>Remote</strong></dfn>: this is the version of a repo that is hosted on
                GitHub's server. It can be connected to local clones so that changes can be
                synced.</li>
            <li><dfn><strong>Working Directory</strong></dfn>: your local version of files on your
                computer, where you make changes. All Git files have a three part working directory:
                    <dfn>unstaged</dfn>, <dfn>staged</dfn>, <dfn>committed</dfn>. If you make edits
                to a repo those changes sit unstaged until you have consciously added those changes
                to the staging area. Staging changes allows you to review before committing.</li>
            <li><dfn><strong>Commit</strong></dfn>: a.k.a. <q>revision</q>, this is an individual
                change to a file (or set of files). It's like when you save a file, except with Git,
                every time you save it creates a unique ID <span class="smaller">(the <q>SHA</q> or
                        <q>hash</q>)</span> that allows you to keep record of what changes were made
                when and by who. Commits usually contain a commit message which is a brief
                description of what changes were made.</li>
            <li><dfn><strong>Pushing</strong></dfn>: refers to sending your committed changes to a
                remote repository such as GitHub.com. For instance, if you change something locally,
                you'd want to then push those changes so that others may access them.</li>
            <li><dfn><strong>Pulling</strong></dfn>: is the combined process of
                        <dfn><strong>fetching</strong></dfn> (getting the latest changes from a
                remote repo without merging them in order to compare them to the code residing on
                your local machine) and <dfn><strong>merging</strong></dfn> (applying the changes
                from one file to another). For instance, if someone has edited the remote file
                you're both working on, you'll want to pull in those changes to your local copy so
                that it's up to date.</li>
            <!--<li><dfn><strong></strong></dfn>:</li>-->
            <!--RJP:2016-08-24: We should add more as we see necessary. I didn't want to overload with terms especially since each of these terms comes up in greater detail throughout the rest of the tutorial, but we could add more to this list as we see necessary. -->
        </ul>
        <p><span class="smaller">The above definitions are compiled from the following three sites,
                which can be visited for definitions of even more Git terms: <a
                    href="https://www.kernel.org/pub/software/scm/git/docs/gitglossary.html"
                    target="_blank">kernel.org</a>, <a
                    href="https://betterexplained.com/articles/aha-moments-when-learning-git/"
                    target="_blank">betterexplained.com</a>, and <a
                    href="https://help.github.com/articles/github-glossary/" target="_blank"
                    >help.github.com</a></span></p>
        <br />
        <h1 id="account">Let's get started!</h1>
        <h3>How to create a GitHub account:</h3>
        <p>Because GitHub is a social networking site, where people post their code so that it will
            be accessible to others, using it requires creating an account. You can create a free
            account by navigating to <a href="https://www.github.com" target="_blank"
            >github.com</a>. You are not required to create an account using your pitt.edu address;
            however, associating an educational email address with your account may give you
            additional benefits <span class="smaller">(including five free private repos)</span>. To
            create your account, enter a user name, email address, and password and then click the
            green button that says <q>Sign up for GitHub</q>. Be sure to select the free option, and
            then click the green button that says <q>Finish sign up</q>. After creating your
            account, GitHub will prompt you to verify your email address and decide on the frequency
            of GitHub email notifications. Make sure to follow the link in the verification email.
            It is important while you are enrolled in this coding course that you regularly checking
            GitHub so you may decide to allow all notifications <span class="smaller">(knowing you
                can change this later)</span>. You will then be directed back to your account.</p>
        <p><img src="git_shell/creatingAccount_05.jpg" alt="Creating An Account" /></p>
        <p><strong>Note: We have highlighted some recommended features of your GitHub account that
                you should take some time exploring further.</strong></p>
        <p><img src="git_shell/creatingAccount_07.jpg" alt="Creating An Account" /></p>
        <h3 id="setup">Downloading Git Shell</h3>
        <p>Git is available for <a
                href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank"
                >download</a> on all three of these platforms: Linux, Mac, and Windows. To download
            Git on your local machine follow the instructions available <a
                href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank"
                >here</a>. Since platform downloads differ we are not going to go through a
            step-by-step installation process. However, our suggested settings are as follows:</p>
        <ul>
            <li>If the download asks about <q>Adjusting your PATH environment</q>, we recommend
                selecting <q>Use Git Bash only</q> as it provides an unmodified PATH.</li>
            <li>If the download asks about <q>Configuring the line ending conversations</q>, we
                recommend choosing the option of <q>Checkout Windows-style, commit Unix-style line
                    endings</q>.</li>
            <li>When the download asks where you want Git saved and/or where to save future repos
                you NEED to browse your computer and save to a logical place on your local machine
                that you know how to access easily.</li>
        </ul>
        <p>When downloading Git on a Windows computer and/or if you are less experienced Mac user we
            suggest downloading <a href="https://desktop.github.com/" target="_blank">GitHub
                Desktop</a> because the storing of configuration information is made simplier
            through the GUI client that is installed with GitHub Desktop. Once download of GitHub
            Desktop is complete you should open the GUI client (the icon with the purple cat head)
            and to the gear symbol in the top right of the client. From there click on
                <q>Options</q>. This is where you can configure your local Git setup with your
            GitHub account.</p>
        <p><img src="git_shell/desktopClientDownload_05.jpg" alt="Using GUI to Configure Account"
             /></p>
        <p>After you have completed configuraition using the GUI client exit the client and remove
            the shortcut from your desktop. Do not uninstall the GUI in case you descide to change
            your configuration in the future, but remove any created shortcuts because the Git Shell
            will be where you will do the rest of your Git interactions. If you choose to <a
                href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank"
                >download</a> without the GUI you will need to configure your local machine's Git
            with your online GitHub account. Begin configuration by opening Git Shell <span
                class="smaller">(might be called Git Bash on your computer)</span> and entering the
            following commands <span class="smaller">(after the <span class="code"
            >$</span>)</span>:</p>
        <span class="code">$ git config --global user.name "YOUR NAME"</span>
        <br />
        <span class="code">$ git config --global user.email "YOUR EMAIL ADDRESS"</span>
        <p>Be sure to use the same email address you used when signing up for your GitHub account.
            This will add your name and email to a file named <dfn>.gitconfig</dfn> in your home
            directory. To verify that you entered your information correctly use the command:</p>
        <span class="code">$ git config --list</span>. <p>For more information on the <code>git
                config</code> command visit <a href="https://git-scm.com/docs/git-config"
                target="_blank">the Pro Git guide on configuration</a>. Note: in oder to cache your
            username and password, if you have downloading Git without the GUI client, you will need
            to follow further directions found on <a
                href=" https://help.github.com/articles/caching-your-github-password-in-git/#platform-all"
                target="_blank">help.github.com</a>.</p>
        <h3 id="repo">Creating a Repository</h3>
        <h4>What is a repo?</h4>
        <p>Projects on GitHub are stored in repos (short for repositories), which you can think of
            as equivalent to folders or directories on your computer. Repos can contain plain files
            and subdirectories, so you can use the subdirectories to organize your project files
            according to whatever hierarchy makes sense to you. Initially you may want to put all of
            your project files into the main repo directory, and as you add additional files and
            your project becomes more complex, you can think about creating subdirectories and
            distributing the files among them according to file type or other criteria. Your project
            mentor will advise you about how to structure the directory space for your project.</p>
        <p>Your remote project repo will reside on the GitHub server, which is the remote server
            that is accessible to others. It is possible to edit files directly on the server using
            the GitHub interface, but the typical interaction with GitHub is to work on copies of
            the project files <span class="smaller">a.k.a. repo clone</span> on your own machine and
            then, when you are satisfied with the state of your work, to push (upload) your new or
            modified files to the remote server so that your project partners will have access to
            them. Similarly, when your project partners push their changes to the server, those
            won’t be reflected in the copies on your local machine until you pull (download) them.
            The process of uploading files you have modified from your local machine to the GitHub
            server, and of downloading from the GitHub server files that your project partners may
            have developed or modified and uploaded, is called syncing (short for synchronization).
            Syncing with command line requires two basic commands: <code>git pull</code> and
                <code>git push</code>. The command <code>git pull</code> can be broken down into
                <code>git fetch</code> and <code>git merge</code>, but we will discuss the
            distinction later in this tutorial. When you begin a work session, you should start by
            syncing your local project space with the server using <code>git pull</code>, so that
            you’ll catch up on any changes other project contributors have made. When you reach a
            stopping point in your work <span class="smaller">(when you have new or updated files
                that your project partners need to see)</span>, you should commit (<code>git
                commit</code>) and sync again, but this time using <code>git push</code>. You don’t
            have to push after every keystroke, but you should commit regularly and push whenever
            you reach a reasonably stable intermediate point to which your project partners should
            have access.</p>
        <h4>How to create a repo:</h4>
        <p>The best way to initiate a new repo, for our group projects, will be to create it through
            the online web interface. Easy to follow instructions on how to do this can be found <a
                href="https://help.github.com/articles/create-a-repo/" target="_blank">on
                help.github.com</a>. If a repo is created through the web interface it will need to
            be <a href="#cloning">cloned</a> in order for you to access it and begin working on your
            local computer. Only one member of your project team will need to create the project
            repo, and all other team members will <a href="#cloning">clone</a> from that repo.</p>
        <span class="smaller">(If you wish to create a repo by using Git Shell you only need to know
            one command: <code>$ git init</code>. This initializes a git repository by creating the
            initial .git directory in a new or an existing project pending on the directory
            preceding the command.)</span>
        <!-- rjp:2016-1-15: we need to test how to link local repos created with "git init" to the remote GitHub server. git remote add [shortname] [url] seems to be what all of the documentation point to; however, when I attempted to do this it didn't work (for the url I copy and pasted in the HTTP for my GitHub profile) -->
        <h3 id="collaborators">Adding and Deleting project collaborators</h3>
        <p>Alongside version control, one of GitHub's most useful features is that it supports
            collaboration. Forget the days of emailing a file back and forth between group members
            as it is updated, or waiting to edit a document for fear of losing simultaneous edits.
            GitHub allows multiple collaborators to manage a repository. The only way to handle
            collaborators is through the web interface:</p>
        <ol>
            <li>Go to <a href="https://www.github.com">https://www.github.com</a></li>
            <li>Sign in and navigate to your profile. <p><img src="git_shell/addCollaborator_00.jpg"
                        alt="Adding a Collaborator" /></p>
            </li>
            <li>Choose the repositories tab from your profile.</li>
            <li>Select the repo to which you want to add a collaborator.</li>
            <li>Select <q>Settings</q> at the top of the screen.</li>
            <li>On the Settings page, move to the menu on the left side of the page, and select
                    <q>Collaborators</q>. <p><img src="git_shell/addCollaborator_03.jpg"
                        alt="Adding a Collaborator" /></p></li>
            <li>Type the user name of the collaborator you want to add. (This means that you’ll need
                to ask your collaborators to tell you their GitHub user names in advance.) As you
                type, a drop down list will be generated matching what you have typed. Select the
                user you would like to add from the list. Then click Add collaborator.</li>
        </ol>
        <p>In the future, if collaborators need to be removed simply navigate this same path and
            there will be an option beside each collaborator to remove them.</p>
        <h3 id="cloning">Cloning</h3>
        <p>As we explain above, the way you work on your project (create files, edit files, delete
            files) is to work on them on your local machine and then sync any modifications to the
            GitHub server, so that they will be accessible to your project partners. The Git term
            for copying a project from the GitHub server to your computer initially so that you can
            begin to work on it locally is called <dfn>cloning</dfn>. You only have to clone a
            project once, when you first begin to work on it. <dfn>Cloning</dfn> is the copying of a
            project already in existence on the GitHub server to your local computer so that you can
            begin to work on it; whereas, syncing is exchanging updates between your local computer
            and the GitHub server after you’ve already cloned the repo and established a local copy
            in which you can work. This working model separates saving your work to your local
            computer <span class="smaller">(which you should do <strong>frequently</strong>)</span>
            and syncing your local clone of the repo with the master copy on the GitHub server, a
            design that protects you from uploading mistakes to the server. That is, you do your
            development on your local machine, where only you have access to the files, and when
            you’re ready to share your work with your project partners, you sync (upload) it
            explicitly to the server.</p>
        <h4 id="nav">Navigating Directories</h4>
        <p>Before you clone a repo, you need to understand how to navigate between directories using
            Git Shell. When opening Git Shell from a shortcut link you will be placed in the main
            configuration folder you set up when installing Git. The following image explains how
            you navigate between directories:</p>
        <div class="commandImg">
            <img src="git_shell/navDirectory.jpg" alt="navigating through directories" />
        </div>
        <h4>How to clone an existing repo:</h4>
        <p>To clone a repo from the remote online server using command line you use one easy
            command: <code>git clone</code>. After <code>git clone</code> you copy the url of the
            repo you wish to clone, a space, and then a name for the folder where the cloned repo
            will exist.</p>
        <div class="commandImg">
            <img src="git_shell/cloningArepo.jpg" alt="cloning a repo" />
        </div>
        <p>This creates a copy of the entire repository on your local machine and adds the original
            location as a remote so you can pull from it again and push to it if you have
            permissions. Note: you will only be able to directly push changes to the GitHub server
            if you have been added as a project collaborator. Later in this tutorial we will discuss
            how you can contribute to other GitHub projects that you are not a collaborator on via
                    <dfn><a href="#fork">forking</a></dfn> and a <dfn>pull request</dfn>.</p>
        <h3 id="working">Basic Git workflow:</h3>
        <p>When making changes to a repo it is important to remember the three parts or your Git
            repo on your local machine: <dfn>unstaged</dfn>, <dfn>staged</dfn>,
            <dfn>committed</dfn>. If you make edits to a repo those changes sit unstaged until you
            have consciously added those changes to the staging area. This mean you could modify a
            file multiple times without documenting every single keystroke before asking Git to
            track those changes. Once you have added changes to the staging area Git will monitor if
            any new changes differ from what was added and mark those changes as unstaged. Staging
            changes allows you to review before committing.</p>
        <p><img src="git_shell/gitWorkflow.jpg" alt="git workflow" /></p>
        <ol>
            <li>Before you begin working you <strong>ALWAYS</strong> need to be sure your local repo
                is up-to-date with the remote GitHub repo. To do this we can either use the commands
                    <code>git fetch</code> and <code>git merge</code> or the single command
                    <code>git pull</code>. By using <code>git fetch</code> and <code>git
                    merge</code> you can first see the changes that are being brought into your
                local repo (or <dfn>fetched</dfn>) from the remote repo. This allows for you to,
                upon review, make the decision to <dfn>merge</dfn> those remote changes with your
                local repo. The command <code>git pull</code> combines the two previously mentioned
                commands into one step, which can be convenient yet dangerous if there is a
                possibility of the changes coming in to conflict with files you may have edited
                without committing. <p><img src="git_shell/gitFetchANDgitMerge.jpg"
                        alt="git fetch and git merge" />
                    <span class="smaller">Some believe it is best practice to review all of the
                        remote files you are bringing into your local repo before merging. A <a
                            href="http://longair.net/blog/2009/04/16/git-fetch-and-merge/"
                            target="_blank">detailed argument</a> for always using <code>git
                            fetch</code> and <code>git merge</code> over <code>git pull</code> has
                        been made.</span></p>
            </li>
            <li>Begin working by modifying files in your <dfn>working directory</dfn>. When you want
                to change a file, edit your local copy. You can do this by accessing the files on
                your local machine, like you would any file stored normally on your computer, and
                making changes. Be sure new files get saved in the file location configured with
                Git.</li>
            <li>After you have files created in your <dfn>working directory</dfn> you need to inform
                Git that you saved the files in the git configured directory with purpose and tell
                git to take a snapshot of the changes. Unlike other VCSs, Git has something called
                the <q>staging area</q> or <q>index</q>. This is an intermediate area where commits
                can be formatted and reviewed before completing the commit. To stage a file, use the
                command <code>git add</code>. If you want to stage all of the changed or newly
                created and deleted files stored in the working directory you can type <code>git add
                    -A</code>. To specify that you only want to stage a certain type of file you use
                an asterisk. For example: to stage all of the .html files you type <code>git add
                    *.html</code>. If there is only a single file you want to stage you can type the
                filename after the command. For example: <code>git add index.html</code>. <p><img
                        src="git_shell/gitAdd.jpg" alt="staging files" /></p> As you are working on
                files it is important to always remember that although you are working locally you
                will need to check frequently with your project team to be sure new changes they may
                have made will not cause the files you are editing a merge conflict. For example:
                you are editing an XML transcription and one of your team members is going through
                all of the XML documents and replacing hyphens with the unicode. Your partner edits
                many portions of the same document you are working in and pushes those changes to
                the GitHub repo. Since you're not sure if those changes will cause a merge conflict
                or not you need to store your changes without adding them to the staging area so you
                can pull your partner's changes in first. Git allows you to do this very simply with
                the command <code>git stash</code>. This command stashes your changes outside of
                your working directory while you pull in your partner's remote changes. You then can
                return your stashed files to your working directory and continue by adding your
                changes to the staging area. For more information on <code>git stash</code> visit <a
                    href="https://git-scm.com/docs/git-stash" target="_blank">the Pro Git guide on
                    stashing</a></li>
            <li>When you reach a point where you want to sum up the progress of your work in
                preparation for sharing, you do a commit. This takes the files as they are in the
                staging area and stores the staged snapshot permanently to your local Git directory.
                This is done with the command <code>git commit</code>. To write a commit message
                right inside of Git Shell type <code>git commit -m</code> followed by the commit
                message in quotes. Git requires a commit message when committing. Think of commit
                messages as the breadcrumbs of your project for yourself and your team members;
                every commit message documents changes to the project with an author and time stamp.
                        <p><img src="git_shell/gitCommit.jpg" alt="git commit" /></p></li>
            <li>Once you are ready to share your changes with the rest of your project team you need
                to push your local changes to the remote GitHub server. This is done with the
                command <code>git push</code>. <p><img src="git_shell/gitPush.jpg" alt="git push"
                     /></p></li>
        </ol>
        <h3 id="issue">GitHub as Social Media: Issues and Wikis</h3>
        <p>As discussed above, GitHub serves as a social media network that stores and talks to Git
            repositories. The GitHub interface is useful for many aspects of project management. The
            key parts of GitHub's interface besides the remote storage of project files are the
            issues boards, wikis, and data visualizations. <a target="_blank"
                href="https://help.github.com/articles/about-github-wikis/">Wikis</a> and <a
                href="https://guides.github.com/features/issues/" target="_blank">issues</a> are
            often used in projects to manage tasks and communicate between project team members and
            the GitHub community with project problems and updates. The data visualizations are
            helpful in mining a project's information on collaborators and development.</p>
        <p>To create or comment on an issue navigate to the desired repo and click on the
                <q>Issues</q> tab near the top of the page; notice there is also a tab for Wikis.
            Issues and Wikis on GitHub are written in <dfn>Markdown Language</dfn>. In fact,
                <dfn>markdown</dfn> is used for styling all forms of writing on the GitHub platform.
            GitHub offers a <a href="https://guides.github.com/features/mastering-markdown/"
                target="_blank">comprehensive guide to writing markdown</a> that we recommend you
            review; however, when writing on the GitHub interface there are options similar to
            Microsoft Word that can be toggled to have a specific styling applied to your text.</p>
        <p>Besides project team communication, another important aspect of project management is
            data preservation. Long-term preservation can be defined as the ability to provide
            continued access to digital materials, or at least to the information contained in them,
            indefinitely. A sustainable preservation program should address organizational issues,
            technological concerns and the digital curation/data management process. Using Git and
            GitHub already provides one means of data preservation; however, it is important to
            realize that all of the data collected through the use of Git / GitHub is also important
            to preserve alongside the literal files of your project. One option we have researched
            to be viable for creating a backup of your Git and GitHub data is <a
                href="https://backhub.co/" target="_blank">backhub.co</a>. Another nifty tool that
            we recommend you update frequently is the <a href="https://archive.org/web/"
                target="_blank">online digital archive of websites</a>. By adding updates to this
            site you can go back and review previous saved versions of how your websites looked.
            Besides data preservation it is important to also be able to mine your GitHub data. The
            GitHub interface makes this really simple. In any repo, at the top of the page, there
            are two tabs that are particularly useful for mining your GitHub data: <q>Pulse</q> and
                <q>Graphs</q>. A repo's pulse visualizes the activity of the GitHub repo, while
            Graphs visualize everything from specific user contributions to the types of files
            stored in the repo. These visualizations can be useful when trying to determine details
            about how the repo (and therefore project) grows and changes over time.</p>
        <h1 id="cheatSheet">Common Git Commands:</h1>
        <p>Here is a list of commands used most frequently, and some options to modify the results
            of each command. Some of the commands listed here are associated with <a
                href="#advanced">advanced project management</a> while others are more basic. We
            have not listed every possible command; however we can recommend these sites to review
            more commands: <a href="https://git-scm.com/docs" target="_blank"
                >the Pro Git Guide</a>, <a
                href="https://www.siteground.com/tutorials/git/commands.htm" target="_blank"
                    >siteground.com</a>, <a
                        href="https://www.atlassian.com/git/tutorials/undoing-changes/" target="_blank"
                        >atlassian.com</a>, and <a
                href="https://orga.cat/posts/most-useful-git-commands" target="_blank"
                >orga.cat</a>. Another really great thing
            about Git is that it has been in existence since 2005 and is used widely among computer
            programers; therefore, the resources on Git and Git commands are vast!</p>
        <ul style="list-style-type:none">
            <li><a href="https://git-scm.com/docs/git-help" target="_blank"><code>git
                    help</code></a>: possibly the most useful Git command, this command allows you
                to search the most common Git commands in the command/terminal shell. If you follow
                this command with another command or concept <span class="smaller">(ie. <code>git
                        help push</code>)</span> Git generates a html page detailing the command or
                concept as well as possible options for its use.</li>
            <li><a href="https://git-scm.com/docs/git-init" target="_blank"><code>git
                    init</code></a>: initializes a git repository by creating the initial .git
                directory in a new or in an existing project.</li>
            <li><a href="https://git-scm.com/docs/git-clone" target="_blank"><code>git
                    clone</code></a>: copies an existing GitHub repo to local machine.</li>
            <li><a href="https://git-scm.com/docs/git-status" target="_blank"><code>git
                        status</code></a>: checks the working directory to see if up-to-date with
                the remote repo.</li>
            <li><a href="https://git-scm.com/docs/git-add" target="_blank"><code>git add</code></a>:
                a.k.a. staging changes, adds changes to staging area of the working directory. This
                command is the first step in committing changes to your local version of the repo
                before pushing them to the remote GitHub version of the repo. By adding
                    <code>-A</code>
                <span class="smaller">(<code>git add -A</code>)</span> Git adds, modifies, and
                removes ALL entries to match the working directory. To specify that you only want to
                stage a certain type of file you use an asterisk. <span class="smaller">For example:
                    to stage all of the .html files you type <code>git add *.html</code>.</span> If
                there is only a single file you want to stage you can type the filename after the
                command. <span class="smaller">For example: <code>git add
                index.html</code></span></li>
            <li><a href="https://git-scm.com/docs/git-commit" target="_blank"><code>git
                        commit</code></a>: tells Git to record the changes made to your version of
                the repo. Every commit needs to have a message that explains what files have been
                edited/added. After the command add <code>-m</code> and then the commit message in
                quotes <span class="smaller">(<code>git commit -m "This is where your message
                        goes"</code>)</span>. You can skip the command <code>git add</code> by using
                    <code>git commit -a -m</code> followed by your commit message. However, best
                practice is to add and commit in separate steps so you are aware of the files being
                added before making the commit.</li>
            <li><a href="" target="_blank"><code></code></a>:</li>
            <li><a href="" target="_blank"><code></code></a>:</li>
            <li><a href="" target="_blank"><code></code></a>:</li>
            <li><a href="" target="_blank"><code></code></a>:</li>
            <li><a href="" target="_blank"><code></code></a>:</li>
            <li><a href="" target="_blank"><code></code></a>:</li>
            <li><a href="" target="_blank"><code></code></a>:</li>
        </ul>
        <h1 id="advanced">Advanced Project Management</h1>
        <h3 id="branch">Branching: what is it, and why do we do it?</h3>
        <p>Branching means you diverge from the main line of development and continue to do work
            without messing with that main line. The master branch is the main branch of a project.
            When working in projects with multiple collaborators it may be important that the master
            branch not have errors, and always be in good working order. If everyone is writing new
            code into the master branch, it’s possible for the master branch to enter an unstable
            state temporarily. To avoid that, projects may require that all developers work on
            different parts of the project separately, in their own branches, and merge their
            individual development branches into the master branch only once they are confident that
            it won’t have a destabilizing effect. This can be useful even in single-developer
            projects if you need to maintain multiple versions, such as a stable branch that people
            should be able to download and use and a development branch that will eventually become
            the new stable branch, but that isn’t yet stable. Branches can be merged and deleted
            because a branch is an inalienable part of the repo in which it is created in; thus,
            working in a branch requires you to already have a cloned repo. Just to be clear, when
            you clone a repo that has existing branches the entire repo gets cloned including all of
            the repo's existing branches.</p>
        <p>To really understand the way Git does branching, we need to take a step back and examine
            how Git stores its data. As stated above, Git doesn’t store data as a series of
            changesets or differences, but instead as a series of snapshots. When you make a commit,
            Git stores a commit object that contains a pointer to the snapshot of the content you
            staged. This object also contains the author’s name and email, the message that you
            typed, and pointers to the commit or commits that directly came before this commit (its
            parent or parents). A branch, in Git, is simply a lightweight movable pointer to one of
            these commits. The default branch name in Git is master. As you start making commits,
            you’re given a master branch that points to the last commit you made. Every time you
            commit, it moves forward automatically. </p>
        <h4>How to create a branch:</h4>
        <p>Before creating a branch it is important to note what branches are already a part of your
            local repo. To do this we use the command <code>git branch</code>. This command lists
            all the branches only in the local repo. The master branch came automatically from the
            source repo upon cloning as the main branch of the repo. To see all of the local
            branches, including the master branch, and the remote branches that can be pushed to we
            use the command <code>git branch --all</code>. Now to create a new local branch use the
            command <code>git branch</code> followed by what you wish to call the branch. For
            example: <code>git branch development</code> will create a branch called
                <q>development</q>. To verify that a new branch was added, re-run the <code>git
                branch</code> command. You should now see the new branch. The star to the left of a
            branch name indicates where you are working, and this can be verified with <code>git
                status</code>. When you run <code>git status</code> Git Shell should return a line
            listing what branch you are on. For example: if you are working on the master branch Git
            will return the line <q>On branch master</q>.</p><div class="commandImg">
            <img src="git_shell/createBranch.jpg" alt="creating a branch" />
        </div>
        <h4>How to switch between branches:</h4>
        <p>If you want work to appear under a specific branch you will need to switch to the desired
            branch before committing changes. To switch branches use the command <code>git
                checkout</code> followed by the name of the branch you wish to switch to. For
            example: <code>git checkout development</code> will switch you over to the
                <q>development</q> branch.<br />
            <img src="git_shell/switchBranch_01.jpg" alt="switching branches to change files" />
            <br /> You can verify that you have successfully switched branches by using either of
            the previously explained commands: <code>git branch</code> or <code>git
            status</code>.</p><div class="commandImg">
            <img src="git_shell/switchBranch_02.jpg" alt="switching between branches" />
        </div>
        <h4>How to merge branches and push changes to remote:</h4>
        <p>Once there have been changes made via a branch and you wish to combine those changes with
            the main (master) branch, you will need to do the following:</p>
        <ol>
            <li>Use the command <code>git diff</code> followed by the names of the two branches you
                want to compare. For example: <code>git diff master development</code> will show the
                differences between the master branch and the development branch. If you want to
                just get a list of the files changed between the two branches you can change the
                command to <code>git diff --name-only</code> again followed by the names of the two
                branches you wish to compare.</li>
            <li>Then use <code>git status</code> or <code>git branch</code> to verify what branch
                you are currently working in. If you are not on the master branch you should switch
                to it using <code>git checkout master</code>.</li>
            <li>Once you have reviewed the differences you will want to merge the two branches. This
                is done with the <code>git merge</code> command followed by the name of the branch
                being merged into the master branch. For example: <code>git merge
                development</code>.</li>
            <li>To verify the merge was successful you can run <code>git diff</code> again, and if
                Git does not return anything that means there are no differences between the two
                branches.</li>
            <li>Now when you run <code>git status</code> it will show that local master is ahead of
                the remote origin. To fix this and bring the remote origin repo up to date with your
                local master, run the <code>git push</code> command.</li>
        </ol>
        <div class="commandImg">
            <img src="git_shell/mergeBranch.jpg" alt="merging branches" />
        </div>
        <p>If you have done work in a branch, and you do not want to merge the changes into the
            master branch until others on your team have reviewed it you can push the branch and its
            changes before merging. As long as you have the branch selected in Git Shell, you can
            use the command <code>git push origin</code> followed by the name of the branch to
            update the remote repo with the new branch. For example: <code>git push origin
                development</code> will push the development branch and its changes to the remote
            origin. Now if another collaborator wish to clone the repo, and bring in your branch to
            their local repo they will be able to do so.</p>
        <h4>How to delete a branch:</h4>
        <p>Some branches are created only temporarily; therefore, you may desire to delete a branch
            before or after merging. The command <code>git branch -d</code> followed by the branch
            name will delete the specified branch; if the branch is not fully merged in its upstream
            branch or contained in the current branch, this command will fail with a warning.
            Otherwise if the branch has been successfully merged with another branch then the
            command will go through and the branch will be removed. Use <code>git branch</code> to
            verify deletion. If you wish to remove the branch whether it has been merged or not the
            command is altered slightly: <code>git branch -D</code> followed by the branch name.</p>
        <div class="commandImg">
            <img src="git_shell/deleteBranch.jpg" alt="deleting a branch" />
        </div>
        <h3 id="fork">Forking: what is it and why do we do it?</h3>
        <p>Part of the open-source etiquette of GitHub is that developers are encouraged to copy and
            then improve code originally created by others. GitHub supports the creation of derived
            projects through forking. When you fork a repo, you create a copy of it under your own
            account, where it acquires an independent identity. You can do anything with a repo you
            created by forking someone else’s project that you can with a repo you created from
            scratch. The moment that you create the fork, your new repo is no longer synchronized
            with changes in the repo from which you copied it originally. If you fork a repo and
            make changes that you would then like to contribute to the original source, you can
            issue a pull request, inviting the developers of the original repo to merge your forked
            repo's changes into their original project.</p>
        <h4>How to fork and how to work in a fork:</h4>
        <p>To begin forking you need to navigate to the repo you wish to fork, and select the
                <q>fork</q> button in the top right of the screen.</p>
        <div class="accountImg">
            <img src="git_shell/forking_01.jpg" alt="forking a repo" />
        </div>
        <p>Next, you will need to navigate to the new forked repo created on your account. From
            here, follow the steps above on <a href="#cloning">cloning</a>, and clone the repo using
                <code>git clone</code> and the HTTPS of the forked repo. Make sure you are cloning
            the repo that is located on your account and not the source repo you forked from.</p>
        <div class="accountImg">
            <img src="git_shell/forking_02.jpg" alt="forking a repo" />
        </div>
        <p>In order for the forked repo to reference the source repo, you will need to set up the
            remote upstream. Do this with the following command: <code>git remote add
                upstream</code> followed by the HTTPS of the source repo. Use the command <code>git
                remote</code> or <code>git remote -v</code> to show all of the remote versions of
            your repository. You should see <q>origin</q> (the direct remote version of the forked
            repo) and the upstream you just created. When you want to bring any new changes made on
            the source repo into your forked repo, you can use the following commands to do so:
                <code>git fetch upstream</code> and <code>git merge
            upstream</code><!-- rjp:2016-01-19: having a conflict with merge upstream need to verify this command -->.
            These commands function the same way in a fork as they did in the cloned repo (reference
            above for more detail).</p>
        <div class="commandImg">
            <img src="git_shell/forking_03.jpg" alt="forking a repo" />
        </div>
        <p>In the <a href="#branch">branching section</a> of this tutorial we discussed why using a
            branch is good practice. When working in a forked repo, branching becomes even more
            important and practical. The master branch is better to be left free of
            developmental/experimental changes so that it can be used to sync with the upstream
            (source repo). Therefore, it is best to add and change files in branches of your fork.
            After you have created a branch, modified files, and committed said changes use the
            command <code>git log --pretty=short</code> to see a listing of commits. Finally, to
            push all the local branches and change to the forked remote use the command <code>git
                push --all -u</code>. This command also sets up upstream tracking on all of the
            branches.</p>
        <div class="commandImg">
            <img src="git_shell/forking_04.jpg" alt="forking a repo" />
        </div>
        <h4>How to issue a pull request:</h4>
        <p>Now if we go back to our fork on GitHub, we can see that GitHub noticed that we pushed a
            new branch with changes to the source repo's code. GitHub presents us with a big green
            button to compare our changes and open a Pull Request to the original project. You can
            alternatively go to the <q>Branches</q> page at
            https://github.com/[user]/[project]/branches to locate your branch and open a new Pull
            Request from there.</p>
        <div class="accountImg">
            <img src="git_shell/pullRequest_01.jpg" alt="creating a pull request" />
        </div>
        <p>If we click that green button, we'll see a screen that asks us to give our Pull Request a
            title and description. It is almost always worthwhile to put some effort into this,
            since a good description helps the owner of the original project determine what you were
            trying to do, whether your proposed changes are correct, and whether accepting the
            changes would improve the original project or not. We also see a list of the commits in
            our forked repo's branch that are <q>ahead</q> of the master branch. Should this branch
            get merged by the project owner, a unified diff of all the changes will be made.</p>
        <div class="accountImg">
            <img src="git_shell/pullRequest_02.jpg" alt="creating a pull request" />
        </div>
        <p>When you hit the create pull request button, the owner of the project you forked from
            will get a notification that someone is suggesting a change with a link to a page that
            has all of the information you provided on it. At this point, the project owner can look
            at the suggested changes and merge it, reject it or comment on it. It is possible that
            the owner will ask you to <q>rebase from master</q> and resubmit a pull request. This
            might happen if a series of changes were made on the source repo's master branch that
            you had failed to fetch or if such changes were made after you submitted your request.
            This is not a problem! The following link will take you to a very thorough YouTube video
            on how to do this: <a href="https://www.youtube.com/watch?v=M7ZYkjOWr6g"
                >https://www.youtube.com/watch?v=M7ZYkjOWr6g</a>.</p>
        <h3>In conclusion...</h3>
        <p>Git and GitHub can be a bit confusing for new users, but it makes project management much
            more robust than the available alternatives, and learning to use it is worth the effort.
            This tutorial is designed to get you started, and your instructors (and mentors) are
            available to advise and help if you get stuck or confused. There are a number of
            resources online to further your knowledge, some of which can be found at the following
            links:</p>
        <ul>
            <li><a href="https://git-scm.com/">Pro Book (online version)</a></li>
            <li><a href="http://gitref.org/">Git Reference</a></li>
            <li><a href="https://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git User
                    Manual</a></li>
            <li><a href="https://www.siteground.com/tutorials/git/commands.htm">Git: Tutorial
                    Commands</a></li>
            <li><a href="http://rogerdudler.github.io/git-guide/">Git - the simple guide</a></li>
            <li><a href="https://gist.github.com/hofmannsven/6814451">A simple Git cheatsheet
                    (hosted on GitHub Gist)</a></li>
        </ul>
    </body>
</html>
